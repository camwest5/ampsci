<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ampsci: qip Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<!-- ... other metadata & script includes ... -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ampsci
   </div>
   <div id="projectbrief">c++ program for high-precision atomic structure calculations of single-valence systems</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">qip Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>qip library: A collection of useful functions  
<a href="namespaceqip.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceqip_1_1overloads"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqip_1_1overloads.html">overloads</a></td></tr>
<tr class="memdesc:namespaceqip_1_1overloads"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace qip::overloads provides operator overloads for std::vector <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqip_1_1StrideIterator.html">StrideIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator accounting for a stride.  <a href="classqip_1_1StrideIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqip_1_1ConstStrideIterator.html">ConstStrideIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant iterator accounting for a stride.  <a href="classqip_1_1ConstStrideIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqip_1_1ArrayView.html">ArrayView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A view onto a 1D array; used for rows/collumns of ND array. Can have a stride.  <a href="classqip_1_1ArrayView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqip_1_1less__abs.html">less_abs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing comparisons of absolute values (uses std::abs). Works similarly to std::less.  <a href="structqip_1_1less__abs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqip_1_1StrongType.html">StrongType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A light-weight easy-to-use single-file header-only template class for strong typing.  <a href="structqip_1_1StrongType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqip_1_1Comparison.html">Comparison</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for comparisons. Derive from this to provide !=,&gt;,&lt;=,&gt;=, given == and &lt;.  <a href="classqip_1_1Comparison.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqip_1_1Arithmetic.html">Arithmetic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for Arithmetic operations. Derive from this to provide +,-,*,/, given +=, -=, *=, /=.  <a href="classqip_1_1Arithmetic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqip_1_1Arithmetic2.html">Arithmetic2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for Arithmetic operations. Derive from this to provide +,-,*,/, given +=, -=, *=, /=. Works for two different types.  <a href="classqip_1_1Arithmetic2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aaaf20d224ad6ef434bb4422ee160ef55"><td class="memTemplParams" colspan="2"><a id="aaaf20d224ad6ef434bb4422ee160ef55"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:aaaf20d224ad6ef434bb4422ee160ef55"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#aaaf20d224ad6ef434bb4422ee160ef55">product</a> (T first, Args... rest)</td></tr>
<tr class="memdesc:aaaf20d224ad6ef434bb4422ee160ef55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic product - helper function. <br /></td></tr>
<tr class="separator:aaaf20d224ad6ef434bb4422ee160ef55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5f844bebe3cd686ae41c23e9ab082c"><td class="memTemplParams" colspan="2"><a id="afe5f844bebe3cd686ae41c23e9ab082c"></a>
template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:afe5f844bebe3cd686ae41c23e9ab082c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>NDrange_impl</b> (std::vector&lt; std::array&lt; std::size_t, N &gt;&gt; &amp;result, std::array&lt; std::size_t, N &gt; &amp;current, const std::array&lt; std::size_t, N &gt; &amp;maxValues, std::size_t index)</td></tr>
<tr class="separator:afe5f844bebe3cd686ae41c23e9ab082c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bffe52945e07e097fb95f9877e12a79"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a3bffe52945e07e097fb95f9877e12a79"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a3bffe52945e07e097fb95f9877e12a79">NDrange</a> (std::size_t first, Args... rest)</td></tr>
<tr class="memdesc:a3bffe52945e07e097fb95f9877e12a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic array of all possible indexes.  <a href="namespaceqip.html#a3bffe52945e07e097fb95f9877e12a79">More...</a><br /></td></tr>
<tr class="separator:a3bffe52945e07e097fb95f9877e12a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa8ce8b7b2ea7201cf954b9c52cc2dd"><td class="memTemplParams" colspan="2"><a id="a2fa8ce8b7b2ea7201cf954b9c52cc2dd"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a2fa8ce8b7b2ea7201cf954b9c52cc2dd"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a2fa8ce8b7b2ea7201cf954b9c52cc2dd">max</a> (T first, Args... rest)</td></tr>
<tr class="memdesc:a2fa8ce8b7b2ea7201cf954b9c52cc2dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns maximum of any number of parameters (variadic function) <br /></td></tr>
<tr class="separator:a2fa8ce8b7b2ea7201cf954b9c52cc2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e81dfdf0cd840d0ead840f72a066be"><td class="memTemplParams" colspan="2"><a id="aa9e81dfdf0cd840d0ead840f72a066be"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:aa9e81dfdf0cd840d0ead840f72a066be"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#aa9e81dfdf0cd840d0ead840f72a066be">min</a> (T first, Args... rest)</td></tr>
<tr class="memdesc:aa9e81dfdf0cd840d0ead840f72a066be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns minimum of any number of parameters (variadic function) <br /></td></tr>
<tr class="separator:aa9e81dfdf0cd840d0ead840f72a066be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b99af2e2e2a1d9438a995c2555f51e"><td class="memTemplParams" colspan="2"><a id="a80b99af2e2e2a1d9438a995c2555f51e"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a80b99af2e2e2a1d9438a995c2555f51e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a80b99af2e2e2a1d9438a995c2555f51e">max_abs</a> (T first, Args... rest)</td></tr>
<tr class="memdesc:a80b99af2e2e2a1d9438a995c2555f51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns value with maximum absolute value of any number of parameters (variadic function) <br /></td></tr>
<tr class="separator:a80b99af2e2e2a1d9438a995c2555f51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2670fff7c6536bb13a8d677336e72fb"><td class="memTemplParams" colspan="2"><a id="ac2670fff7c6536bb13a8d677336e72fb"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:ac2670fff7c6536bb13a8d677336e72fb"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#ac2670fff7c6536bb13a8d677336e72fb">min_abs</a> (T first, Args... rest)</td></tr>
<tr class="memdesc:ac2670fff7c6536bb13a8d677336e72fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns value with minimum absolute value of any number of parameters (variadic function) <br /></td></tr>
<tr class="separator:ac2670fff7c6536bb13a8d677336e72fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe1bfb56638d7c8dccdff2d6b8f07ad"><td class="memTemplParams" colspan="2"><a id="a1fe1bfb56638d7c8dccdff2d6b8f07ad"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a1fe1bfb56638d7c8dccdff2d6b8f07ad"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a1fe1bfb56638d7c8dccdff2d6b8f07ad">max_difference</a> (T first, Args... rest)</td></tr>
<tr class="memdesc:a1fe1bfb56638d7c8dccdff2d6b8f07ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns max{args..} - min{args...}, for any number of args (variadic) <br /></td></tr>
<tr class="separator:a1fe1bfb56638d7c8dccdff2d6b8f07ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93902898009ff74b7ff28f72ba7bcf2"><td class="memTemplParams" colspan="2"><a id="ae93902898009ff74b7ff28f72ba7bcf2"></a>
template&lt;int n, typename T &gt; </td></tr>
<tr class="memitem:ae93902898009ff74b7ff28f72ba7bcf2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#ae93902898009ff74b7ff28f72ba7bcf2">pow</a> (T x)</td></tr>
<tr class="memdesc:ae93902898009ff74b7ff28f72ba7bcf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">x^n for integer n (n compile-time template parameter), x any arithmetic type (T). Returns double for inverse powers, T otherwise <br /></td></tr>
<tr class="separator:ae93902898009ff74b7ff28f72ba7bcf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5f2fdede884dd745ce55f2da0f5d7d"><td class="memTemplParams" colspan="2"><a id="a9d5f2fdede884dd745ce55f2da0f5d7d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9d5f2fdede884dd745ce55f2da0f5d7d"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a9d5f2fdede884dd745ce55f2da0f5d7d">pow</a> (T x, int n)</td></tr>
<tr class="memdesc:a9d5f2fdede884dd745ce55f2da0f5d7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">x^n for integer n (runtime n), x any floating point type (T). <br /></td></tr>
<tr class="separator:a9d5f2fdede884dd745ce55f2da0f5d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762e6d5bf39ffca404e2d778fafbb0d9"><td class="memTemplParams" colspan="2"><a id="a762e6d5bf39ffca404e2d778fafbb0d9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a762e6d5bf39ffca404e2d778fafbb0d9"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a762e6d5bf39ffca404e2d778fafbb0d9">sign</a> (T value)</td></tr>
<tr class="memdesc:a762e6d5bf39ffca404e2d778fafbb0d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns sign of value. Note: sign(0)==0. <br /></td></tr>
<tr class="separator:a762e6d5bf39ffca404e2d778fafbb0d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af091ad44ba19b2538888cf9487af0e31"><td class="memTemplParams" colspan="2"><a id="af091ad44ba19b2538888cf9487af0e31"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af091ad44ba19b2538888cf9487af0e31"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#af091ad44ba19b2538888cf9487af0e31">clip</a> (T value, T <a class="el" href="namespaceqip.html#a80b99af2e2e2a1d9438a995c2555f51e">max_abs</a>)</td></tr>
<tr class="memdesc:af091ad44ba19b2538888cf9487af0e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clips value to between -max &lt;= value &lt;= max clip(x,max) : |x| &gt; max, ret max; if |x|&lt;-max, -max; else x. <br /></td></tr>
<tr class="separator:af091ad44ba19b2538888cf9487af0e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62de3c5b336d174e02feabf709867f3"><td class="memTemplParams" colspan="2"><a id="ab62de3c5b336d174e02feabf709867f3"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab62de3c5b336d174e02feabf709867f3"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#ab62de3c5b336d174e02feabf709867f3">chop</a> (T value, T <a class="el" href="namespaceqip.html#ac2670fff7c6536bb13a8d677336e72fb">min_abs</a>)</td></tr>
<tr class="memdesc:ab62de3c5b336d174e02feabf709867f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets values |v|&lt;min to zero; if |v|&gt;=min, returns v. <br /></td></tr>
<tr class="separator:ab62de3c5b336d174e02feabf709867f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b6f143abffe9690de405fddebf6098"><td class="memTemplParams" colspan="2">template&lt;typename Function , typename Real &gt; </td></tr>
<tr class="memitem:a87b6f143abffe9690de405fddebf6098"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; Real, Real &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a87b6f143abffe9690de405fddebf6098">derivative</a> (Function y, Real x, Real delta_target=Real{1.0e-6}, Real dx=Real{0.01}, unsigned it_limit=250)</td></tr>
<tr class="memdesc:a87b6f143abffe9690de405fddebf6098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slow, but accurate, method of finding derivative of function (y) at a point (x). Returns derivative + error estimate.  <a href="namespaceqip.html#a87b6f143abffe9690de405fddebf6098">More...</a><br /></td></tr>
<tr class="separator:a87b6f143abffe9690de405fddebf6098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a65342a9b56894381f0ed477fd0904e"><td class="memTemplParams" colspan="2">template&lt;typename Function , typename Real &gt; </td></tr>
<tr class="memitem:a0a65342a9b56894381f0ed477fd0904e"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; Real, Real &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a0a65342a9b56894381f0ed477fd0904e">Newtons</a> (Function f, Real x, Real delta_target=Real{1.0e-6}, Real dx=Real{0.01}, unsigned it_limit=250)</td></tr>
<tr class="memdesc:a0a65342a9b56894381f0ed477fd0904e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve f(x) = 0 for x using Newtons method. Returns root + error estimate/.  <a href="namespaceqip.html#a0a65342a9b56894381f0ed477fd0904e">More...</a><br /></td></tr>
<tr class="separator:a0a65342a9b56894381f0ed477fd0904e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae4d24ef243017154241af136479e14"><td class="memTemplParams" colspan="2"><a id="a7ae4d24ef243017154241af136479e14"></a>
template&lt;typename Function , typename Real &gt; </td></tr>
<tr class="memitem:a7ae4d24ef243017154241af136479e14"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; Real, Real &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a7ae4d24ef243017154241af136479e14">Newtons</a> (Function f, Real x, std::pair&lt; Real, Real &gt; bounds, Real delta_target=Real{1.0e-6}, Real dx=Real{0.01}, unsigned it_limit=250)</td></tr>
<tr class="memdesc:a7ae4d24ef243017154241af136479e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve f(x) = 0 for x using Newtons method. Returns root + error estimate. Enforced to be between bounds. <br /></td></tr>
<tr class="separator:a7ae4d24ef243017154241af136479e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace80c89c04a21d525dc9242303bf1ef8"><td class="memItemLeft" align="right" valign="top"><a id="ace80c89c04a21d525dc9242303bf1ef8"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>omp_details</b> ()</td></tr>
<tr class="separator:ace80c89c04a21d525dc9242303bf1ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cac1e9173a8f0ab589e7aa127e7edcd"><td class="memItemLeft" align="right" valign="top"><a id="a3cac1e9173a8f0ab589e7aa127e7edcd"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>random_string</b> (std::size_t length)</td></tr>
<tr class="separator:a3cac1e9173a8f0ab589e7aa127e7edcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95825e5328321b8e0f83c230a42bd384"><td class="memItemLeft" align="right" valign="top"><a id="a95825e5328321b8e0f83c230a42bd384"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a95825e5328321b8e0f83c230a42bd384">fstring</a> (const std::string format,...)</td></tr>
<tr class="memdesc:a95825e5328321b8e0f83c230a42bd384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a formatted std::string, with formatting printf-like commands. Note: maximum string lenth is 256 characters. If longer string required, use provided overload. <br /></td></tr>
<tr class="separator:a95825e5328321b8e0f83c230a42bd384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f77c0373bce44b37d7e26af0f03de4"><td class="memItemLeft" align="right" valign="top"><a id="a97f77c0373bce44b37d7e26af0f03de4"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a97f77c0373bce44b37d7e26af0f03de4">fstring</a> (const std::size_t size, const std::string format,...)</td></tr>
<tr class="memdesc:a97f77c0373bce44b37d7e26af0f03de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload: size is maximum string length (buffer size). <br /></td></tr>
<tr class="separator:a97f77c0373bce44b37d7e26af0f03de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae6b3539250c3e8aec56e34d8588fb15"><td class="memItemLeft" align="right" valign="top"><a id="aae6b3539250c3e8aec56e34d8588fb15"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqip.html#aae6b3539250c3e8aec56e34d8588fb15">wildcard_compare</a> (std::string_view s1, std::string_view s2)</td></tr>
<tr class="memdesc:aae6b3539250c3e8aec56e34d8588fb15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two strings, s1 and s2. s2 may contain ONE wildcard ('*') which will match anything. <br /></td></tr>
<tr class="separator:aae6b3539250c3e8aec56e34d8588fb15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0c485769c3134b6746de97235628d7"><td class="memItemLeft" align="right" valign="top"><a id="aec0c485769c3134b6746de97235628d7"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqip.html#aec0c485769c3134b6746de97235628d7">tolower</a> (char ch)</td></tr>
<tr class="memdesc:aec0c485769c3134b6746de97235628d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">return static_cast&lt;char&gt;(std::tolower(static_cast&lt;unsigned char&gt;(ch))); <br /></td></tr>
<tr class="separator:aec0c485769c3134b6746de97235628d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964aa73cc730e146911083bbf6828a41"><td class="memItemLeft" align="right" valign="top"><a id="a964aa73cc730e146911083bbf6828a41"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a964aa73cc730e146911083bbf6828a41">ci_compare</a> (std::string_view s1, std::string_view s2)</td></tr>
<tr class="memdesc:a964aa73cc730e146911083bbf6828a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Case insensitive string compare. Essentially: LowerCase(s1)==LowerCase(s2) <br /></td></tr>
<tr class="separator:a964aa73cc730e146911083bbf6828a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea76ebd33dccecb8ded6e3b3ba447bc"><td class="memItemLeft" align="right" valign="top"><a id="a7ea76ebd33dccecb8ded6e3b3ba447bc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a7ea76ebd33dccecb8ded6e3b3ba447bc">ci_wc_compare</a> (std::string_view s1, std::string_view s2)</td></tr>
<tr class="memdesc:a7ea76ebd33dccecb8ded6e3b3ba447bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two strings, s1 and s2. s2 may contain ONE wildcard ('*') which will match anything. Case Insensitive version. <br /></td></tr>
<tr class="separator:a7ea76ebd33dccecb8ded6e3b3ba447bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a229fdb6b5d87ccda7d872052a8072b"><td class="memItemLeft" align="right" valign="top"><a id="a2a229fdb6b5d87ccda7d872052a8072b"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a2a229fdb6b5d87ccda7d872052a8072b">Levenstein</a> (std::string_view a, std::string_view b)</td></tr>
<tr class="memdesc:a2a229fdb6b5d87ccda7d872052a8072b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple non-optimised implementation of the Levenshtein distance. <br /></td></tr>
<tr class="separator:a2a229fdb6b5d87ccda7d872052a8072b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7591544d632a747d922c0968a18a1482"><td class="memItemLeft" align="right" valign="top"><a id="a7591544d632a747d922c0968a18a1482"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a7591544d632a747d922c0968a18a1482">ci_Levenstein</a> (std::string_view a, std::string_view b)</td></tr>
<tr class="memdesc:a7591544d632a747d922c0968a18a1482"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple non-optimised implementation of the Levenshtein distance (case insensitive) <br /></td></tr>
<tr class="separator:a7591544d632a747d922c0968a18a1482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c662c083f1a052ac4ef6d5e3cd4a90d"><td class="memItemLeft" align="right" valign="top"><a id="a0c662c083f1a052ac4ef6d5e3cd4a90d"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a0c662c083f1a052ac4ef6d5e3cd4a90d">closest_match</a> (std::string_view test_string, const std::vector&lt; std::string &gt; &amp;list)</td></tr>
<tr class="memdesc:a0c662c083f1a052ac4ef6d5e3cd4a90d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the closest match in list to test_string (return iterator) <br /></td></tr>
<tr class="separator:a0c662c083f1a052ac4ef6d5e3cd4a90d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf877c3d7f4589f0c680e22640e821b5"><td class="memItemLeft" align="right" valign="top"><a id="acf877c3d7f4589f0c680e22640e821b5"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqip.html#acf877c3d7f4589f0c680e22640e821b5">ci_closest_match</a> (std::string_view test_string, const std::vector&lt; std::string &gt; &amp;list)</td></tr>
<tr class="memdesc:acf877c3d7f4589f0c680e22640e821b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the closest match (case insensitive) in list to test_string (return iterator) <br /></td></tr>
<tr class="separator:acf877c3d7f4589f0c680e22640e821b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4980b240c34b6656b3653bd5e41e37a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a4980b240c34b6656b3653bd5e41e37a1">string_is_integer</a> (std::string_view s)</td></tr>
<tr class="memdesc:a4980b240c34b6656b3653bd5e41e37a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a string-like s is integer-like (including -)  <a href="namespaceqip.html#a4980b240c34b6656b3653bd5e41e37a1">More...</a><br /></td></tr>
<tr class="separator:a4980b240c34b6656b3653bd5e41e37a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad738ef953ec9c22c08b2a8014f12c5e8"><td class="memItemLeft" align="right" valign="top"><a id="ad738ef953ec9c22c08b2a8014f12c5e8"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqip.html#ad738ef953ec9c22c08b2a8014f12c5e8">split</a> (const std::string &amp;s, char delim=' ')</td></tr>
<tr class="memdesc:ad738ef953ec9c22c08b2a8014f12c5e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a string by delimeter into a vector. <br /></td></tr>
<tr class="separator:ad738ef953ec9c22c08b2a8014f12c5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2706f1118f1c85c034374d42933126ea"><td class="memItemLeft" align="right" valign="top"><a id="a2706f1118f1c85c034374d42933126ea"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a2706f1118f1c85c034374d42933126ea">concat</a> (const std::vector&lt; std::string &gt; &amp;v, const std::string &amp;delim=&quot;&quot;)</td></tr>
<tr class="memdesc:a2706f1118f1c85c034374d42933126ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes vector of strings, concats into single string, with optional delimeter. <br /></td></tr>
<tr class="separator:a2706f1118f1c85c034374d42933126ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7db247b4ce6a20fd2141c0ad6510f8"><td class="memItemLeft" align="right" valign="top"><a id="ada7db247b4ce6a20fd2141c0ad6510f8"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqip.html#ada7db247b4ce6a20fd2141c0ad6510f8">wrap</a> (const std::string &amp;input, std::size_t at=80, const std::string &amp;prefix=&quot;&quot;)</td></tr>
<tr class="memdesc:ada7db247b4ce6a20fd2141c0ad6510f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the string, 'input', at line 'at'. Optionally appends a prefix 'prefix' to each line. Does not split words (if can be avoided) <br /></td></tr>
<tr class="separator:ada7db247b4ce6a20fd2141c0ad6510f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd7b5f3792ab47d819e447bb3c1b1a2"><td class="memItemLeft" align="right" valign="top"><a id="a7fd7b5f3792ab47d819e447bb3c1b1a2"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a7fd7b5f3792ab47d819e447bb3c1b1a2">int_to_roman</a> (int a)</td></tr>
<tr class="memdesc:a7fd7b5f3792ab47d819e447bb3c1b1a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts integer, a, to Roman Numerals. Assumed that |a|&lt;=4000. <br /></td></tr>
<tr class="separator:a7fd7b5f3792ab47d819e447bb3c1b1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559d27aa2d91e7e1a3024df3835872aa"><td class="memTemplParams" colspan="2"><a id="a559d27aa2d91e7e1a3024df3835872aa"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a559d27aa2d91e7e1a3024df3835872aa"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a559d27aa2d91e7e1a3024df3835872aa">merge</a> (std::vector&lt; T &gt; first, const std::vector&lt; T &gt; &amp;second, const Args &amp;...rest)</td></tr>
<tr class="memdesc:a559d27aa2d91e7e1a3024df3835872aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges a number of vectors: {a,b,c},{d,e},{f} -&gt; {a,b,c,d,e,f}. <br /></td></tr>
<tr class="separator:a559d27aa2d91e7e1a3024df3835872aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2feca8ceeedd078122dc9bac30a7d6"><td class="memTemplParams" colspan="2"><a id="aca2feca8ceeedd078122dc9bac30a7d6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aca2feca8ceeedd078122dc9bac30a7d6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#aca2feca8ceeedd078122dc9bac30a7d6">compare</a> (const std::vector&lt; T &gt; &amp;first, const std::vector&lt; T &gt; &amp;second)</td></tr>
<tr class="memdesc:aca2feca8ceeedd078122dc9bac30a7d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directly compare two arithmetic vectors of the same type and length. Returns pair {delta, itr} where delta = |max|{first - second}, itr is iterator to position in first vector where the maximum delta occured. Note: Maximum is by magnitude, but delta is signed as (first-second) <br /></td></tr>
<tr class="separator:aca2feca8ceeedd078122dc9bac30a7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c41c906c90e34a8f2770b69ab2b486c"><td class="memTemplParams" colspan="2"><a id="a4c41c906c90e34a8f2770b69ab2b486c"></a>
template&lt;typename T , typename U , typename Func &gt; </td></tr>
<tr class="memitem:a4c41c906c90e34a8f2770b69ab2b486c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a4c41c906c90e34a8f2770b69ab2b486c">compare</a> (const std::vector&lt; T &gt; &amp;first, const std::vector&lt; U &gt; &amp;second, Func &amp;func)</td></tr>
<tr class="memdesc:a4c41c906c90e34a8f2770b69ab2b486c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two vectors of the same length, according to the rule given by func. Returns pair {delta, itr} where delta = max{|func(first,second)|}, itr is iterator to position in first vector where the maximum delta occured. Note: Maximum is by magnitude. <br /></td></tr>
<tr class="separator:a4c41c906c90e34a8f2770b69ab2b486c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1250da0bd75d06567ef62d2b3fe349de"><td class="memTemplParams" colspan="2"><a id="a1250da0bd75d06567ef62d2b3fe349de"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1250da0bd75d06567ef62d2b3fe349de"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a1250da0bd75d06567ef62d2b3fe349de">compare_eps</a> (const std::vector&lt; T &gt; &amp;first, const std::vector&lt; T &gt; &amp;second)</td></tr>
<tr class="memdesc:a1250da0bd75d06567ef62d2b3fe349de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares values of two arithmetic vectors of the same type and length, relative to second value. Returns pair {eps, itr} where eps = |max|{(first - second)/second}, itr is iterator to position in first vector where the maximum eps occured. Note: Maximum is by magnitude, but eps is signed as (first-second)/second. <br /></td></tr>
<tr class="separator:a1250da0bd75d06567ef62d2b3fe349de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ad20d5fb047e9cac680e9ce436fa4a"><td class="memTemplParams" colspan="2"><a id="a08ad20d5fb047e9cac680e9ce436fa4a"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a08ad20d5fb047e9cac680e9ce436fa4a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a08ad20d5fb047e9cac680e9ce436fa4a">add</a> (std::vector&lt; T &gt; *first, const std::vector&lt; T &gt; &amp;second, const Args &amp;...rest)</td></tr>
<tr class="memdesc:a08ad20d5fb047e9cac680e9ce436fa4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds any number of vectors, in place (modifies first vector). Must be of same type. May allocate; will resize first to be size of largest vector. <br /></td></tr>
<tr class="separator:a08ad20d5fb047e9cac680e9ce436fa4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2649f424673296bcdd83e8cef5f80cf"><td class="memTemplParams" colspan="2"><a id="ac2649f424673296bcdd83e8cef5f80cf"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:ac2649f424673296bcdd83e8cef5f80cf"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#ac2649f424673296bcdd83e8cef5f80cf">add</a> (std::vector&lt; T &gt; first, const std::vector&lt; T &gt; &amp;second, const Args &amp;...rest)</td></tr>
<tr class="memdesc:ac2649f424673296bcdd83e8cef5f80cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds any number of vectors. Must be of same type. Size of returned vector will be size of largest vector; may allocate more than once if vectors are not all of same size. <br /></td></tr>
<tr class="separator:ac2649f424673296bcdd83e8cef5f80cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75f1779029d7480d8cf81499e1ad2a8"><td class="memTemplParams" colspan="2"><a id="ac75f1779029d7480d8cf81499e1ad2a8"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:ac75f1779029d7480d8cf81499e1ad2a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#ac75f1779029d7480d8cf81499e1ad2a8">multiply</a> (std::vector&lt; T &gt; *first, const std::vector&lt; T &gt; &amp;second, const Args &amp;...rest)</td></tr>
<tr class="memdesc:ac75f1779029d7480d8cf81499e1ad2a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies any number of (arithmetic) vectors, in place (modifies first vector). Must be of same type. May allocate; will resize first to be size of largest vector. <br /></td></tr>
<tr class="separator:ac75f1779029d7480d8cf81499e1ad2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4fb79992105ced6dee0ec3fd4d85316"><td class="memTemplParams" colspan="2"><a id="ad4fb79992105ced6dee0ec3fd4d85316"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:ad4fb79992105ced6dee0ec3fd4d85316"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#ad4fb79992105ced6dee0ec3fd4d85316">multiply</a> (std::vector&lt; T &gt; first, const std::vector&lt; T &gt; &amp;second, const Args &amp;...rest)</td></tr>
<tr class="memdesc:ad4fb79992105ced6dee0ec3fd4d85316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies any number of vectors. Must be of same type. Size of returned vector will be size of largest vector; may allocate more than once if vectors are not all of same size. <br /></td></tr>
<tr class="separator:ad4fb79992105ced6dee0ec3fd4d85316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1400c774970ff089ae662d3013a0fa18"><td class="memTemplParams" colspan="2"><a id="a1400c774970ff089ae662d3013a0fa18"></a>
template&lt;typename F , typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a1400c774970ff089ae662d3013a0fa18"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a1400c774970ff089ae662d3013a0fa18">compose</a> (const F &amp;func, std::vector&lt; T &gt; *first, const std::vector&lt; T &gt; &amp;second, const Args &amp;...rest)</td></tr>
<tr class="memdesc:a1400c774970ff089ae662d3013a0fa18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes any number of vectors, in place (modifies first vector), using the provided function. Must be of same type. May allocate; will resize first to be size of largest vector. e.g., qip::compose(std::plus{}, &amp;vo, v2, v3); same as qip::add(&amp;vo, v2, v3) <br /></td></tr>
<tr class="separator:a1400c774970ff089ae662d3013a0fa18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3718a9092655efe9f5f09c8d9d54bfc3"><td class="memTemplParams" colspan="2"><a id="a3718a9092655efe9f5f09c8d9d54bfc3"></a>
template&lt;typename F , typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a3718a9092655efe9f5f09c8d9d54bfc3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a3718a9092655efe9f5f09c8d9d54bfc3">compose</a> (const F &amp;func, std::vector&lt; T &gt; first, const std::vector&lt; T &gt; &amp;second, const Args &amp;...rest)</td></tr>
<tr class="memdesc:a3718a9092655efe9f5f09c8d9d54bfc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes any number of vectors. Must be of same type. Size of returned vector will be size of largest vector; may allocate more than once if vectors are not all of same size. <br /></td></tr>
<tr class="separator:a3718a9092655efe9f5f09c8d9d54bfc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1419dc459f6c79c3271ce4c7608292a6"><td class="memTemplParams" colspan="2"><a id="a1419dc459f6c79c3271ce4c7608292a6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1419dc459f6c79c3271ce4c7608292a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a1419dc459f6c79c3271ce4c7608292a6">scale</a> (std::vector&lt; T &gt; *vec, T x)</td></tr>
<tr class="memdesc:a1419dc459f6c79c3271ce4c7608292a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place scalar multiplication of std::vector - types must match. <br /></td></tr>
<tr class="separator:a1419dc459f6c79c3271ce4c7608292a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b64ac3915ed88109c23ef7a011a5a7"><td class="memTemplParams" colspan="2"><a id="a97b64ac3915ed88109c23ef7a011a5a7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a97b64ac3915ed88109c23ef7a011a5a7"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a97b64ac3915ed88109c23ef7a011a5a7">scale</a> (std::vector&lt; T &gt; vec, T x)</td></tr>
<tr class="memdesc:a97b64ac3915ed88109c23ef7a011a5a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar multiplication of std::vector - types must match. <br /></td></tr>
<tr class="separator:a97b64ac3915ed88109c23ef7a011a5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4090db55ea9f6ddb8049de78eef37a0f"><td class="memTemplParams" colspan="2"><a id="a4090db55ea9f6ddb8049de78eef37a0f"></a>
template&lt;typename T , typename N &gt; </td></tr>
<tr class="memitem:a4090db55ea9f6ddb8049de78eef37a0f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a4090db55ea9f6ddb8049de78eef37a0f">uniform_range</a> (T first, T last, N number)</td></tr>
<tr class="memdesc:a4090db55ea9f6ddb8049de78eef37a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces a uniformly*(see below) distributed range of values between [first,last] with number steps. number must be at least 2. first+last are guarenteed to be the first and last points in the range. For integral T, range will not be perfectly uniform, due to [first, ..., last] guarentee and rounding; also in this case same value may appear more than once if too-many steps are requested. <br /></td></tr>
<tr class="separator:a4090db55ea9f6ddb8049de78eef37a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40451d413829b19aab5a69909f69ade"><td class="memTemplParams" colspan="2"><a id="ae40451d413829b19aab5a69909f69ade"></a>
template&lt;typename T , typename N &gt; </td></tr>
<tr class="memitem:ae40451d413829b19aab5a69909f69ade"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#ae40451d413829b19aab5a69909f69ade">logarithmic_range</a> (T first, T last, N number)</td></tr>
<tr class="memdesc:ae40451d413829b19aab5a69909f69ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces a logarithmicly*(see below) distributed range of values between [first,last] with number steps. number must be at least 2. first+last are guarenteed to be the first and last points in the range. For integral T, range will not be perfectly logarithmic, due to [first, ..., last] guarentee and rounding; also in this case same value may appear more than once if too-many steps are requested. <br /></td></tr>
<tr class="separator:ae40451d413829b19aab5a69909f69ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78acb5d0ed70eead7db3ae450244a494"><td class="memTemplParams" colspan="2"><a id="a78acb5d0ed70eead7db3ae450244a494"></a>
template&lt;typename T , typename N &gt; </td></tr>
<tr class="memitem:a78acb5d0ed70eead7db3ae450244a494"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a78acb5d0ed70eead7db3ae450244a494">loglinear_range</a> (T first, T last, T b, N number)</td></tr>
<tr class="memdesc:a78acb5d0ed70eead7db3ae450244a494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces a Log-Linear distributed range of values between [first,last] with number steps. number must be at least 3. first+last are guarenteed to be the first and last points in the range. T must be floating point. Range is roughly logarithmic for values below 'b', and linear for values above b. Not tested for negative values. <br /></td></tr>
<tr class="separator:a78acb5d0ed70eead7db3ae450244a494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14597b0bab192d9257ce42c1fc70e85"><td class="memTemplParams" colspan="2"><a id="af14597b0bab192d9257ce42c1fc70e85"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:af14597b0bab192d9257ce42c1fc70e85"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#af14597b0bab192d9257ce42c1fc70e85">multiply_at</a> (std::size_t i, const T &amp;first, const Args &amp;...rest)</td></tr>
<tr class="memdesc:af14597b0bab192d9257ce42c1fc70e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">first[i]*...rest[i] &ndash; used to allow inner_product <br /></td></tr>
<tr class="separator:af14597b0bab192d9257ce42c1fc70e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa139bdda88f1dd07dade6962ecbd94cd"><td class="memTemplParams" colspan="2"><a id="aa139bdda88f1dd07dade6962ecbd94cd"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:aa139bdda88f1dd07dade6962ecbd94cd"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#aa139bdda88f1dd07dade6962ecbd94cd">inner_product</a> (const T &amp;first, const Args &amp;...rest)</td></tr>
<tr class="memdesc:aa139bdda88f1dd07dade6962ecbd94cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic inner product (v1,v2,...vn) : sum_i v1[i]*v2[i]*...vn[i]. <br /></td></tr>
<tr class="separator:aa139bdda88f1dd07dade6962ecbd94cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6393c1e917792bd35b1f0df797d937"><td class="memTemplParams" colspan="2"><a id="a1f6393c1e917792bd35b1f0df797d937"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a1f6393c1e917792bd35b1f0df797d937"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inner_product_sub</b> (std::size_t p0, std::size_t pinf, const T &amp;first, const Args &amp;...rest)</td></tr>
<tr class="separator:a1f6393c1e917792bd35b1f0df797d937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625393770774da4553b27cbb967cf9c9"><td class="memTemplParams" colspan="2"><a id="a625393770774da4553b27cbb967cf9c9"></a>
template&lt;typename F , typename T &gt; </td></tr>
<tr class="memitem:a625393770774da4553b27cbb967cf9c9"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply_to</b> (const F &amp;func, T list)</td></tr>
<tr class="separator:a625393770774da4553b27cbb967cf9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1672ff178b5aeb9535c0eca6e7e91a"><td class="memTemplParams" colspan="2"><a id="a7e1672ff178b5aeb9535c0eca6e7e91a"></a>
template&lt;typename T , typename Func &gt; </td></tr>
<tr class="memitem:a7e1672ff178b5aeb9535c0eca6e7e91a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a7e1672ff178b5aeb9535c0eca6e7e91a">select_if</a> (const std::vector&lt; T &gt; &amp;in, Func condition)</td></tr>
<tr class="memdesc:a7e1672ff178b5aeb9535c0eca6e7e91a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a subset of a vector, whose element match condition. By copy. condition must have function signature: bool condition(T) <br /></td></tr>
<tr class="separator:a7e1672ff178b5aeb9535c0eca6e7e91a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7cd248db2ab60ba720702329248f400"><td class="memTemplParams" colspan="2"><a id="ab7cd248db2ab60ba720702329248f400"></a>
template&lt;typename T , typename Func &gt; </td></tr>
<tr class="memitem:ab7cd248db2ab60ba720702329248f400"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#ab7cd248db2ab60ba720702329248f400">insert_into_if</a> (const std::vector&lt; T &gt; &amp;in, std::vector&lt; T &gt; *inout, Func condition)</td></tr>
<tr class="memdesc:ab7cd248db2ab60ba720702329248f400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from in into inout, if condition is met. <br /></td></tr>
<tr class="separator:ab7cd248db2ab60ba720702329248f400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2628db4b1490c94df434d06b079d40"><td class="memItemLeft" align="right" valign="top"><a id="a1c2628db4b1490c94df434d06b079d40"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>progbar</b> (int i, int <a class="el" href="namespaceqip.html#a2fa8ce8b7b2ea7201cf954b9c52cc2dd">max</a>, int length=50)</td></tr>
<tr class="separator:a1c2628db4b1490c94df434d06b079d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f3de5012f99fe145d780e974ac609d"><td class="memItemLeft" align="right" valign="top"><a id="a32f3de5012f99fe145d780e974ac609d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>progbar50</b> (int i, int <a class="el" href="namespaceqip.html#a2fa8ce8b7b2ea7201cf954b9c52cc2dd">max</a>)</td></tr>
<tr class="separator:a32f3de5012f99fe145d780e974ac609d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aae0f3a7b4bdf301c1d6f8bf8799144a5"><td class="memItemLeft" align="right" valign="top"><a id="aae0f3a7b4bdf301c1d6f8bf8799144a5"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>use_omp</b> = false</td></tr>
<tr class="separator:aae0f3a7b4bdf301c1d6f8bf8799144a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>qip library: A collection of useful functions </p>
<p>Collection of handy tools. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a87b6f143abffe9690de405fddebf6098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b6f143abffe9690de405fddebf6098">&#9670;&nbsp;</a></span>derivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function , typename Real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;Real, Real&gt; qip::derivative </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>delta_target</em> = <code>Real{1.0e-6}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>dx</em> = <code>Real{0.01}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>it_limit</em> = <code>250</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slow, but accurate, method of finding derivative of function (y) at a point (x). Returns derivative + error estimate. </p>
<p>delta_target is target for |dy/dx_n - dy/dx_{n+1}| &lt; delta_target (1.0e-6); dx is initial step-size used to find derivative of f (0.01); it_limit is maximum number of iterations. </p>

</div>
</div>
<a id="a3bffe52945e07e097fb95f9877e12a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bffe52945e07e097fb95f9877e12a79">&#9670;&nbsp;</a></span>NDrange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto qip::NDrange </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variadic array of all possible indexes. </p>
<p>Allows ranged for loop like: for ([i,j,k,m,...,z] : array){ array.at(i,j,k,m,...,z); } Note: not memory efficient at all! Don't use for large arrays </p>

</div>
</div>
<a id="a0a65342a9b56894381f0ed477fd0904e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a65342a9b56894381f0ed477fd0904e">&#9670;&nbsp;</a></span>Newtons()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function , typename Real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;Real, Real&gt; qip::Newtons </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>delta_target</em> = <code>Real{1.0e-6}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>dx</em> = <code>Real{0.01}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>it_limit</em> = <code>250</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve f(x) = 0 for x using Newtons method. Returns root + error estimate/. </p>
<p>x is be initial guess for the root; delta_target is target for |x_n - x_{n+1}| &lt; delta_target (1.0e-6); dx is initial step-size used to find derivative of f (0.01); it_limit is maximum number of iterations. </p>

</div>
</div>
<a id="a4980b240c34b6656b3653bd5e41e37a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4980b240c34b6656b3653bd5e41e37a1">&#9670;&nbsp;</a></span>string_is_integer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool qip::string_is_integer </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a string-like s is integer-like (including -) </p>
<p>e.g., The input strings "16" and "-12" would both return 'true', while "12x" or "12.5" would not. Does this by checking if all characters are integer digits exept first character, which is allowed to be an integer, or '+' or -'- </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jul 12 2024 07:43:56 for ampsci by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
