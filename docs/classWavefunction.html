<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ampsci: Wavefunction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<!-- ... other metadata & script includes ... -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ampsci
   </div>
   <div id="projectbrief">c++ program for high-precision atomic structure calculations of single-valence systems</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classWavefunction-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Wavefunction</div>  </div>
</div><!--header-->
<div class="contents">

<p>Stores Wavefunction (set of valence orbitals, grid, HF etc.)  
 <a href="classWavefunction.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Wavefunction_8hpp_source.html">Wavefunction.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3473b40278e9fb30a09de1341bda6463"><td class="memItemLeft" align="right" valign="top"><a id="a3473b40278e9fb30a09de1341bda6463"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a3473b40278e9fb30a09de1341bda6463">Wavefunction</a> (std::shared_ptr&lt; const <a class="el" href="classGrid.html">Grid</a> &gt; <a class="el" href="classWavefunction.html#a6ba2bc44e2928f2c28fb7d5fd0c913aa">grid</a>, const <a class="el" href="classNuclear_1_1Nucleus.html">Nuclear::Nucleus</a> &amp;<a class="el" href="classWavefunction.html#abf3ed3a958f06edce39b449fb4d7dab6">nucleus</a>, double var_alpha=1.0, const std::string &amp;run_label=&quot;&quot;)</td></tr>
<tr class="memdesc:a3473b40278e9fb30a09de1341bda6463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct with a Grid [shared resource], a nucleus (isotope data etc.), and (optional) fractional variation in alpha [alpha = var_alpha * alpha_0, alpha_0=~1/137]. <br /></td></tr>
<tr class="separator:a3473b40278e9fb30a09de1341bda6463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2b71a07e218611842fd8cb6c9f0cc0"><td class="memItemLeft" align="right" valign="top"><a id="abf2b71a07e218611842fd8cb6c9f0cc0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#abf2b71a07e218611842fd8cb6c9f0cc0">Wavefunction</a> (const <a class="el" href="structGridParameters.html">GridParameters</a> &amp;gridparams, const <a class="el" href="classNuclear_1_1Nucleus.html">Nuclear::Nucleus</a> &amp;<a class="el" href="classWavefunction.html#abf3ed3a958f06edce39b449fb4d7dab6">nucleus</a>, double var_alpha=1.0, const std::string &amp;run_label=&quot;&quot;)</td></tr>
<tr class="memdesc:abf2b71a07e218611842fd8cb6c9f0cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">As above, but Grid is constructed here using given parameters. <br /></td></tr>
<tr class="separator:abf2b71a07e218611842fd8cb6c9f0cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba2bc44e2928f2c28fb7d5fd0c913aa"><td class="memItemLeft" align="right" valign="top"><a id="a6ba2bc44e2928f2c28fb7d5fd0c913aa"></a>
const <a class="el" href="classGrid.html">Grid</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a6ba2bc44e2928f2c28fb7d5fd0c913aa">grid</a> () const</td></tr>
<tr class="memdesc:a6ba2bc44e2928f2c28fb7d5fd0c913aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the radial grid. <br /></td></tr>
<tr class="separator:a6ba2bc44e2928f2c28fb7d5fd0c913aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27930ba61cf17bd3714c094f4499596f"><td class="memItemLeft" align="right" valign="top"><a id="a27930ba61cf17bd3714c094f4499596f"></a>
std::shared_ptr&lt; const <a class="el" href="classGrid.html">Grid</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a27930ba61cf17bd3714c094f4499596f">grid_sptr</a> () const</td></tr>
<tr class="memdesc:a27930ba61cf17bd3714c094f4499596f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy of shared_ptr to grid [shared resource] - used when we want to construct a new object that shares this grid. <br /></td></tr>
<tr class="separator:a27930ba61cf17bd3714c094f4499596f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ce9d37c87076eb78e046e8157ac4b1"><td class="memItemLeft" align="right" valign="top"><a id="ab9ce9d37c87076eb78e046e8157ac4b1"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#ab9ce9d37c87076eb78e046e8157ac4b1">alpha</a> () const</td></tr>
<tr class="memdesc:ab9ce9d37c87076eb78e046e8157ac4b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local value of fine-structure constant. <br /></td></tr>
<tr class="separator:ab9ce9d37c87076eb78e046e8157ac4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86101751063da7534e3a546f8d0a7b7"><td class="memItemLeft" align="right" valign="top"><a id="af86101751063da7534e3a546f8d0a7b7"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#af86101751063da7534e3a546f8d0a7b7">dalpha2</a> () const</td></tr>
<tr class="memdesc:af86101751063da7534e3a546f8d0a7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variation in alpha^2 : x = (alpha/alpha_0)^2 - 1. <br /></td></tr>
<tr class="separator:af86101751063da7534e3a546f8d0a7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf3ed3a958f06edce39b449fb4d7dab6"><td class="memItemLeft" align="right" valign="top"><a id="abf3ed3a958f06edce39b449fb4d7dab6"></a>
const <a class="el" href="classNuclear_1_1Nucleus.html">Nuclear::Nucleus</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#abf3ed3a958f06edce39b449fb4d7dab6">nucleus</a> () const</td></tr>
<tr class="memdesc:abf3ed3a958f06edce39b449fb4d7dab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns Nuclear::nucleus object (contains nuc. parameters) <br /></td></tr>
<tr class="separator:abf3ed3a958f06edce39b449fb4d7dab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323a18d94cb2242a666a584be6ca08bc"><td class="memItemLeft" align="right" valign="top"><a id="a323a18d94cb2242a666a584be6ca08bc"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a323a18d94cb2242a666a584be6ca08bc">Znuc</a> () const</td></tr>
<tr class="memdesc:a323a18d94cb2242a666a584be6ca08bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nuclear charge, Z. <br /></td></tr>
<tr class="separator:a323a18d94cb2242a666a584be6ca08bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a36b73812ebae2e76f55d475149fa9e"><td class="memItemLeft" align="right" valign="top"><a id="a6a36b73812ebae2e76f55d475149fa9e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a6a36b73812ebae2e76f55d475149fa9e">Anuc</a> () const</td></tr>
<tr class="memdesc:a6a36b73812ebae2e76f55d475149fa9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nuclear mass number, A. <br /></td></tr>
<tr class="separator:a6a36b73812ebae2e76f55d475149fa9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736ad360b2a3ea96a65397a08aeffe85"><td class="memItemLeft" align="right" valign="top"><a id="a736ad360b2a3ea96a65397a08aeffe85"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a736ad360b2a3ea96a65397a08aeffe85">get_rrms</a> () const</td></tr>
<tr class="memdesc:a736ad360b2a3ea96a65397a08aeffe85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nuclear rms charge radii, in fm (femptometres) <br /></td></tr>
<tr class="separator:a736ad360b2a3ea96a65397a08aeffe85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d0a729600c3c03d1ff951b658b3f04"><td class="memItemLeft" align="right" valign="top"><a id="ab7d0a729600c3c03d1ff951b658b3f04"></a>
const std::vector&lt; <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#ab7d0a729600c3c03d1ff951b658b3f04">core</a> () const</td></tr>
<tr class="memdesc:ab7d0a729600c3c03d1ff951b658b3f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Core orbitals (frozen HF core) <br /></td></tr>
<tr class="separator:ab7d0a729600c3c03d1ff951b658b3f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e4f9ec508fdb6a4c4487d83e0ebd4e0"><td class="memItemLeft" align="right" valign="top"><a id="a3e4f9ec508fdb6a4c4487d83e0ebd4e0"></a>
const std::vector&lt; <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a3e4f9ec508fdb6a4c4487d83e0ebd4e0">valence</a> () const</td></tr>
<tr class="memdesc:a3e4f9ec508fdb6a4c4487d83e0ebd4e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Valence orbitals (HF or Brueckner orbitals) <br /></td></tr>
<tr class="separator:a3e4f9ec508fdb6a4c4487d83e0ebd4e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb90bf1de6de70625636c4f34c92946c"><td class="memItemLeft" align="right" valign="top"><a id="acb90bf1de6de70625636c4f34c92946c"></a>
std::vector&lt; <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>valence</b> ()</td></tr>
<tr class="separator:acb90bf1de6de70625636c4f34c92946c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e27346c212a70d4a5904c0e0f4dc76e"><td class="memItemLeft" align="right" valign="top"><a id="a7e27346c212a70d4a5904c0e0f4dc76e"></a>
const std::vector&lt; <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a7e27346c212a70d4a5904c0e0f4dc76e">basis</a> () const</td></tr>
<tr class="memdesc:a7e27346c212a70d4a5904c0e0f4dc76e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basis, eigenstates of HF potential. Used for MBPT. Includes Breit and QED (if they are included), but not correlations. <br /></td></tr>
<tr class="separator:a7e27346c212a70d4a5904c0e0f4dc76e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad805ecbd5f2edd79d172af22f7282b60"><td class="memItemLeft" align="right" valign="top"><a id="ad805ecbd5f2edd79d172af22f7282b60"></a>
std::vector&lt; <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>basis</b> ()</td></tr>
<tr class="separator:ad805ecbd5f2edd79d172af22f7282b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380af81d4345cca88bb7a7033055ac80"><td class="memItemLeft" align="right" valign="top"><a id="a380af81d4345cca88bb7a7033055ac80"></a>
const std::vector&lt; <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a380af81d4345cca88bb7a7033055ac80">spectrum</a> () const</td></tr>
<tr class="memdesc:a380af81d4345cca88bb7a7033055ac80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sprectrum: like basis, but includes correlations. <br /></td></tr>
<tr class="separator:a380af81d4345cca88bb7a7033055ac80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbbef1856f3b61f70e4c4346071a3534"><td class="memItemLeft" align="right" valign="top"><a id="abbbef1856f3b61f70e4c4346071a3534"></a>
std::vector&lt; <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>spectrum</b> ()</td></tr>
<tr class="separator:abbbef1856f3b61f70e4c4346071a3534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a243db7d288d72183eb31247071ad2734"><td class="memItemLeft" align="right" valign="top"><a id="a243db7d288d72183eb31247071ad2734"></a>
const std::vector&lt; <a class="el" href="classCI_1_1PsiJPi.html">CI::PsiJPi</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>CIwfs</b> () const</td></tr>
<tr class="separator:a243db7d288d72183eb31247071ad2734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbfcbd050f96193027426e9082dafa2a"><td class="memItemLeft" align="right" valign="top"><a id="adbfcbd050f96193027426e9082dafa2a"></a>
const <a class="el" href="classCI_1_1PsiJPi.html">CI::PsiJPi</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>CIwf</b> (int J, int parity) const</td></tr>
<tr class="separator:adbfcbd050f96193027426e9082dafa2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261552dc583adffa07228f2e64099d8b"><td class="memItemLeft" align="right" valign="top"><a id="a261552dc583adffa07228f2e64099d8b"></a>
const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a261552dc583adffa07228f2e64099d8b">vnuc</a> () const</td></tr>
<tr class="memdesc:a261552dc583adffa07228f2e64099d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nuclear potential. Only provide const version, since HF and WF version of vnuc must be kept in sync. <br /></td></tr>
<tr class="separator:a261552dc583adffa07228f2e64099d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9b64a6be4fc3d2c1aae5f0c2f4c704"><td class="memItemLeft" align="right" valign="top"><a id="aeb9b64a6be4fc3d2c1aae5f0c2f4c704"></a>
const <a class="el" href="classHF_1_1HartreeFock.html">HF::HartreeFock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#aeb9b64a6be4fc3d2c1aae5f0c2f4c704">vHF</a> () const</td></tr>
<tr class="memdesc:aeb9b64a6be4fc3d2c1aae5f0c2f4c704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns ptr to Hartree Fock (class) <br /></td></tr>
<tr class="separator:aeb9b64a6be4fc3d2c1aae5f0c2f4c704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ecaa246b67dbf95aaad44a50920c09"><td class="memItemLeft" align="right" valign="top"><a id="a89ecaa246b67dbf95aaad44a50920c09"></a>
<a class="el" href="classHF_1_1HartreeFock.html">HF::HartreeFock</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>vHF</b> ()</td></tr>
<tr class="separator:a89ecaa246b67dbf95aaad44a50920c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509f57a02029972de24e25d0b7af658b"><td class="memItemLeft" align="right" valign="top"><a id="a509f57a02029972de24e25d0b7af658b"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a509f57a02029972de24e25d0b7af658b">vlocal</a> (int l=0) const</td></tr>
<tr class="memdesc:a509f57a02029972de24e25d0b7af658b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local part of potential, e.g., Vl = Vnuc + Vdir + Vrad_el(l) - can be l-dependent. Returns a copy. <br /></td></tr>
<tr class="separator:a509f57a02029972de24e25d0b7af658b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5192e8da13785d81238e388f3f93483b"><td class="memItemLeft" align="right" valign="top"><a id="a5192e8da13785d81238e388f3f93483b"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a5192e8da13785d81238e388f3f93483b">Hmag</a> (int l=0) const</td></tr>
<tr class="memdesc:a5192e8da13785d81238e388f3f93483b"><td class="mdescLeft">&#160;</td><td class="mdescRight">QED Magnetic form factor. May return empty vector. Not typically l-dependent, but may be in future. Returns a copy. <br /></td></tr>
<tr class="separator:a5192e8da13785d81238e388f3f93483b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c6a0d761a77520d6172c0fe7cfdb32c"><td class="memItemLeft" align="right" valign="top"><a id="a9c6a0d761a77520d6172c0fe7cfdb32c"></a>
const <a class="el" href="classQED_1_1RadPot.html">QED::RadPot</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a9c6a0d761a77520d6172c0fe7cfdb32c">vrad</a> () const</td></tr>
<tr class="memdesc:a9c6a0d761a77520d6172c0fe7cfdb32c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to QED radiative potnential. May be nullptr. <br /></td></tr>
<tr class="separator:a9c6a0d761a77520d6172c0fe7cfdb32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198cfc8349abca6f419ec139d6d34612"><td class="memItemLeft" align="right" valign="top"><a id="a198cfc8349abca6f419ec139d6d34612"></a>
<a class="el" href="classQED_1_1RadPot.html">QED::RadPot</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>vrad</b> ()</td></tr>
<tr class="separator:a198cfc8349abca6f419ec139d6d34612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7d0dcd7f34e802399a123dfc91723a"><td class="memItemLeft" align="right" valign="top"><a id="adc7d0dcd7f34e802399a123dfc91723a"></a>
const MBPT::CorrelationPotential *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#adc7d0dcd7f34e802399a123dfc91723a">Sigma</a> () const</td></tr>
<tr class="memdesc:adc7d0dcd7f34e802399a123dfc91723a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns ptr to (const) Correlation Potential, Sigma. <br /></td></tr>
<tr class="separator:adc7d0dcd7f34e802399a123dfc91723a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a828b36ddcc53c9ae495e905f749d289c"><td class="memItemLeft" align="right" valign="top"><a id="a828b36ddcc53c9ae495e905f749d289c"></a>
MBPT::CorrelationPotential *&#160;</td><td class="memItemRight" valign="bottom"><b>Sigma</b> ()</td></tr>
<tr class="separator:a828b36ddcc53c9ae495e905f749d289c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addcbf541d7102af9c59139aa8ba5288c"><td class="memItemLeft" align="right" valign="top"><a id="addcbf541d7102af9c59139aa8ba5288c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#addcbf541d7102af9c59139aa8ba5288c">Ncore</a> () const</td></tr>
<tr class="memdesc:addcbf541d7102af9c59139aa8ba5288c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of electrons in the core. <br /></td></tr>
<tr class="separator:addcbf541d7102af9c59139aa8ba5288c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebe5ad5f71d03f2b34c2bad30c48b2e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a2ebe5ad5f71d03f2b34c2bad30c48b2e">getState</a> (int n, int k) const</td></tr>
<tr class="memdesc:a2ebe5ad5f71d03f2b34c2bad30c48b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds requested state; returns nullptr if not found.  <a href="classWavefunction.html#a2ebe5ad5f71d03f2b34c2bad30c48b2e">More...</a><br /></td></tr>
<tr class="separator:a2ebe5ad5f71d03f2b34c2bad30c48b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb60417a573a87090c4207db31207c0"><td class="memItemLeft" align="right" valign="top"><a id="afcb60417a573a87090c4207db31207c0"></a>
const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#afcb60417a573a87090c4207db31207c0">getState</a> (std::string_view state) const</td></tr>
<tr class="memdesc:afcb60417a573a87090c4207db31207c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">As above, but takes 'short symbol' (e.g., 6s+, 6p-) <br /></td></tr>
<tr class="separator:afcb60417a573a87090c4207db31207c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae764a7998c1d99c3d090664901f350f0"><td class="memItemLeft" align="right" valign="top"><a id="ae764a7998c1d99c3d090664901f350f0"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#ae764a7998c1d99c3d090664901f350f0">FermiLevel</a> () const</td></tr>
<tr class="memdesc:ae764a7998c1d99c3d090664901f350f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns energy location of the "Fermi Level", - energy half way between core/valence. Defined: 0.5*( max(e_core) + min(e_valence)). Should be -ve. <br /></td></tr>
<tr class="separator:ae764a7998c1d99c3d090664901f350f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f3e32b0b49ce99dbfb7dbfba8cc7a1"><td class="memItemLeft" align="right" valign="top"><a id="a36f3e32b0b49ce99dbfb7dbfba8cc7a1"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a36f3e32b0b49ce99dbfb7dbfba8cc7a1">energy_gap</a> () const</td></tr>
<tr class="memdesc:a36f3e32b0b49ce99dbfb7dbfba8cc7a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Energy gap between lowest valence + highest core state: e(v) - e(c) [should be positive]. <br /></td></tr>
<tr class="separator:a36f3e32b0b49ce99dbfb7dbfba8cc7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae1dac145d79df6ed23600b0588da1e"><td class="memItemLeft" align="right" valign="top"><a id="a4ae1dac145d79df6ed23600b0588da1e"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a4ae1dac145d79df6ed23600b0588da1e">coreConfiguration</a> () const</td></tr>
<tr class="memdesc:a4ae1dac145d79df6ed23600b0588da1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns full core configuration. <br /></td></tr>
<tr class="separator:a4ae1dac145d79df6ed23600b0588da1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7206fa0868e18ef7e2b6e13c0d969d"><td class="memItemLeft" align="right" valign="top"><a id="a7e7206fa0868e18ef7e2b6e13c0d969d"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a7e7206fa0868e18ef7e2b6e13c0d969d">coreConfiguration_nice</a> () const</td></tr>
<tr class="memdesc:a7e7206fa0868e18ef7e2b6e13c0d969d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns core configuration, in nice output notation. <br /></td></tr>
<tr class="separator:a7e7206fa0868e18ef7e2b6e13c0d969d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd94450e44598ec2605a36b468317ba"><td class="memItemLeft" align="right" valign="top"><a id="aafd94450e44598ec2605a36b468317ba"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#aafd94450e44598ec2605a36b468317ba">atom</a> () const</td></tr>
<tr class="memdesc:aafd94450e44598ec2605a36b468317ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">String of atom info (e.g., "Cs, Z=55, A=133") <br /></td></tr>
<tr class="separator:aafd94450e44598ec2605a36b468317ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bfcac1486b376cd770c170f3ed96b41"><td class="memItemLeft" align="right" valign="top"><a id="a6bfcac1486b376cd770c170f3ed96b41"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a6bfcac1486b376cd770c170f3ed96b41">atomicSymbol</a> () const</td></tr>
<tr class="memdesc:a6bfcac1486b376cd770c170f3ed96b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">e.g., "Cs" <br /></td></tr>
<tr class="separator:a6bfcac1486b376cd770c170f3ed96b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407659d98aa3f8c87035ab786cb1ed81"><td class="memItemLeft" align="right" valign="top"><a id="a407659d98aa3f8c87035ab786cb1ed81"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a407659d98aa3f8c87035ab786cb1ed81">identity</a> () const</td></tr>
<tr class="memdesc:a407659d98aa3f8c87035ab786cb1ed81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic symbol, including core ionisation degree and run_label. <br /></td></tr>
<tr class="separator:a407659d98aa3f8c87035ab786cb1ed81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59dfeebe30e21668643ed56b19e73b56"><td class="memItemLeft" align="right" valign="top"><a id="a59dfeebe30e21668643ed56b19e73b56"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a59dfeebe30e21668643ed56b19e73b56">ion_degree</a> (int num_val) const</td></tr>
<tr class="memdesc:a59dfeebe30e21668643ed56b19e73b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">0 for neutral, 1 for singly-ionised etc. <br /></td></tr>
<tr class="separator:a59dfeebe30e21668643ed56b19e73b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7064b45ef5ce6b32752443579fad35c7"><td class="memItemLeft" align="right" valign="top"><a id="a7064b45ef5ce6b32752443579fad35c7"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a7064b45ef5ce6b32752443579fad35c7">ion_symbol</a> (int num_val) const</td></tr>
<tr class="memdesc:a7064b45ef5ce6b32752443579fad35c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">I for neutral, II for singly-ionised etc. <br /></td></tr>
<tr class="separator:a7064b45ef5ce6b32752443579fad35c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e72272c10fd5b60add76bc8e57e1d71"><td class="memItemLeft" align="right" valign="top"><a id="a4e72272c10fd5b60add76bc8e57e1d71"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a4e72272c10fd5b60add76bc8e57e1d71">Zion</a> () const</td></tr>
<tr class="memdesc:a4e72272c10fd5b60add76bc8e57e1d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Effective charge (for core) = Z-N_core. <br /></td></tr>
<tr class="separator:a4e72272c10fd5b60add76bc8e57e1d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabea2bcc724a931e139f4f9a7e80ec9"><td class="memItemLeft" align="right" valign="top"><a id="aaabea2bcc724a931e139f4f9a7e80ec9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#aaabea2bcc724a931e139f4f9a7e80ec9">printCore</a> () const</td></tr>
<tr class="memdesc:aaabea2bcc724a931e139f4f9a7e80ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints table of core orbitals + energies etc. <br /></td></tr>
<tr class="separator:aaabea2bcc724a931e139f4f9a7e80ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188d1b21e04a394d5ff1ed7af5251083"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a188d1b21e04a394d5ff1ed7af5251083">printValence</a> (const std::vector&lt; <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &gt; &amp;tmp_orbitals={}) const</td></tr>
<tr class="memdesc:a188d1b21e04a394d5ff1ed7af5251083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints table of valence orbitals + energies etc.  <a href="classWavefunction.html#a188d1b21e04a394d5ff1ed7af5251083">More...</a><br /></td></tr>
<tr class="separator:a188d1b21e04a394d5ff1ed7af5251083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a5f8afe8f4db1628c1ba52816d2b36"><td class="memItemLeft" align="right" valign="top"><a id="ae8a5f8afe8f4db1628c1ba52816d2b36"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#ae8a5f8afe8f4db1628c1ba52816d2b36">printBasis</a> (const std::vector&lt; <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &gt; &amp;the_basis) const</td></tr>
<tr class="memdesc:ae8a5f8afe8f4db1628c1ba52816d2b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints table of Basis/Spectrum orbitals, compares to HF orbitals. <br /></td></tr>
<tr class="separator:ae8a5f8afe8f4db1628c1ba52816d2b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab31789fb358324bf35331455688b6cb"><td class="memItemLeft" align="right" valign="top"><a id="aab31789fb358324bf35331455688b6cb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#aab31789fb358324bf35331455688b6cb">isInCore</a> (int n, int k) const</td></tr>
<tr class="memdesc:aab31789fb358324bf35331455688b6cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a state is in the core (or valence) list. <br /></td></tr>
<tr class="separator:aab31789fb358324bf35331455688b6cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc58b95259bb712e40f69ecec6653ee3"><td class="memItemLeft" align="right" valign="top"><a id="afc58b95259bb712e40f69ecec6653ee3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isInValence</b> (int n, int k) const</td></tr>
<tr class="separator:afc58b95259bb712e40f69ecec6653ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585c5708dd412db44cc306ee49b5d284"><td class="memItemLeft" align="right" valign="top"><a id="a585c5708dd412db44cc306ee49b5d284"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a585c5708dd412db44cc306ee49b5d284">coreDensity</a> () const</td></tr>
<tr class="memdesc:a585c5708dd412db44cc306ee49b5d284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates rho(r) = sum_c psi^2(r) for core states, c={n,k,m}. <br /></td></tr>
<tr class="separator:a585c5708dd412db44cc306ee49b5d284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f82c43a6c44abb081ff312d58d2490"><td class="memItemLeft" align="right" valign="top"><a id="a28f82c43a6c44abb081ff312d58d2490"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a28f82c43a6c44abb081ff312d58d2490">coreEnergyHF</a> () const</td></tr>
<tr class="memdesc:a28f82c43a6c44abb081ff312d58d2490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates HF core energy (doesn't include magnetic QED?) <br /></td></tr>
<tr class="separator:a28f82c43a6c44abb081ff312d58d2490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf79d11f427d53683cd1b3586a62fa47"><td class="memItemLeft" align="right" valign="top"><a id="acf79d11f427d53683cd1b3586a62fa47"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#acf79d11f427d53683cd1b3586a62fa47">set_HF</a> (const std::string &amp;method=&quot;HartreeFock&quot;, const double x_Breit=0.0, const std::string &amp;in_core=&quot;&quot;, double eps_HF=1.0e-13, bool print=true)</td></tr>
<tr class="memdesc:acf79d11f427d53683cd1b3586a62fa47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises HF object and populates core orbitals (does not solve HF equations) <br /></td></tr>
<tr class="separator:acf79d11f427d53683cd1b3586a62fa47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1694e763b9dab8dbea8832eb5f1ace66"><td class="memItemLeft" align="right" valign="top"><a id="a1694e763b9dab8dbea8832eb5f1ace66"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a1694e763b9dab8dbea8832eb5f1ace66">solve_core</a> (bool print=true)</td></tr>
<tr class="memdesc:a1694e763b9dab8dbea8832eb5f1ace66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs hartree-Fock procedure for core. <br /></td></tr>
<tr class="separator:a1694e763b9dab8dbea8832eb5f1ace66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b6f02e7d753e6db7ce0f13cbf65610"><td class="memItemLeft" align="right" valign="top"><a id="ae8b6f02e7d753e6db7ce0f13cbf65610"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#ae8b6f02e7d753e6db7ce0f13cbf65610">solve_core</a> (const std::string &amp;method, const double x_Breit=0.0, const std::string &amp;in_core=&quot;&quot;, double eps_HF=1.0e-13, bool print=true)</td></tr>
<tr class="memdesc:ae8b6f02e7d753e6db7ce0f13cbf65610"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version will first set_HF(), then solve_core() <br /></td></tr>
<tr class="separator:ae8b6f02e7d753e6db7ce0f13cbf65610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101757ec201b7a6f094a5f1522b9defb"><td class="memItemLeft" align="right" valign="top"><a id="a101757ec201b7a6f094a5f1522b9defb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a101757ec201b7a6f094a5f1522b9defb">solve_valence</a> (const std::string &amp;in_valence_str=&quot;&quot;, const bool print=true)</td></tr>
<tr class="memdesc:a101757ec201b7a6f094a5f1522b9defb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs hartree-Fock procedure for valence: note: poplulates valnece. <br /></td></tr>
<tr class="separator:a101757ec201b7a6f094a5f1522b9defb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb1d340794e7d2a2afaa2e9184ff4c6"><td class="memItemLeft" align="right" valign="top"><a id="addb1d340794e7d2a2afaa2e9184ff4c6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#addb1d340794e7d2a2afaa2e9184ff4c6">hartreeFockBrueckner</a> (const bool print=true)</td></tr>
<tr class="memdesc:addb1d340794e7d2a2afaa2e9184ff4c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms Bruckner valence orbitals: (H_hf + Sigma)|nk&gt; = e|nk&gt;. Replaces existing valence states. <br /></td></tr>
<tr class="separator:addb1d340794e7d2a2afaa2e9184ff4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c8fd9c5768cf18ddb2427f57b8d1b1"><td class="memItemLeft" align="right" valign="top"><a id="a09c8fd9c5768cf18ddb2427f57b8d1b1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a09c8fd9c5768cf18ddb2427f57b8d1b1">fitSigma_hfBrueckner</a> (const std::string &amp;valence_list, const std::vector&lt; double &gt; &amp;fit_energies)</td></tr>
<tr class="memdesc:a09c8fd9c5768cf18ddb2427f57b8d1b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">First, fits Sigma to energies, then forms fitted Brueckner orbitals. <br /></td></tr>
<tr class="separator:a09c8fd9c5768cf18ddb2427f57b8d1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e94127825119943d41752e0ab1d3603"><td class="memItemLeft" align="right" valign="top"><a id="a6e94127825119943d41752e0ab1d3603"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a6e94127825119943d41752e0ab1d3603">radiativePotential</a> (<a class="el" href="structQED_1_1RadPot_1_1Scale.html">QED::RadPot::Scale</a> s, double rcut, double scale_rN, const std::vector&lt; double &gt; &amp;x_spd, bool do_readwrite=true, bool print=true)</td></tr>
<tr class="memdesc:a6e94127825119943d41752e0ab1d3603"><td class="mdescLeft">&#160;</td><td class="mdescRight">OLD: deprecated. <br /></td></tr>
<tr class="separator:a6e94127825119943d41752e0ab1d3603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c5973bd714a32bef87bb434687917b"><td class="memItemLeft" align="right" valign="top"><a id="af4c5973bd714a32bef87bb434687917b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#af4c5973bd714a32bef87bb434687917b">radiativePotential</a> (const <a class="el" href="classIO_1_1InputBlock.html">IO::InputBlock</a> &amp;qed_input, bool do_readwrite, bool print)</td></tr>
<tr class="memdesc:af4c5973bd714a32bef87bb434687917b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates radiative potential, adds to HF potential. <br /></td></tr>
<tr class="separator:af4c5973bd714a32bef87bb434687917b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b4000c0b43b5437b9cb7acae829c90"><td class="memItemLeft" align="right" valign="top"><a id="a10b4000c0b43b5437b9cb7acae829c90"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a10b4000c0b43b5437b9cb7acae829c90">formBasis</a> (const SplineBasis::Parameters &amp;params)</td></tr>
<tr class="memdesc:a10b4000c0b43b5437b9cb7acae829c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates + populates basis [see BSplineBasis]. <br /></td></tr>
<tr class="separator:a10b4000c0b43b5437b9cb7acae829c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854d9e30f51b7978eb01d140bba65893"><td class="memItemLeft" align="right" valign="top"><a id="a854d9e30f51b7978eb01d140bba65893"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a854d9e30f51b7978eb01d140bba65893">formSpectrum</a> (const SplineBasis::Parameters &amp;params)</td></tr>
<tr class="memdesc:a854d9e30f51b7978eb01d140bba65893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates + populates Spectrum [see BSplineBasis]. <br /></td></tr>
<tr class="separator:a854d9e30f51b7978eb01d140bba65893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8802c2a4b75640fab5e08c6f0d3b9a6f"><td class="memItemLeft" align="right" valign="top"><a id="a8802c2a4b75640fab5e08c6f0d3b9a6f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a8802c2a4b75640fab5e08c6f0d3b9a6f">formSigma</a> (int nmin_core=1, int nmin_core_F=1, double r0=1.0e-4, double rmax=30.0, int stride=4, bool each_valence=false, bool include_G=false, bool include_Breit=false, const std::vector&lt; double &gt; &amp;lambdas={}, const std::vector&lt; double &gt; &amp;fk={}, const std::vector&lt; double &gt; &amp;etak={}, const std::string &amp;in_fname=&quot;&quot;, const std::string &amp;out_fname=&quot;&quot;, bool FeynmanQ=false, bool ScreeningQ=false, bool holeParticleQ=false, int lmax=6, double omre=-0.2, double w0=0.01, double wratio=1.5, const std::optional&lt; <a class="el" href="classIO_1_1InputBlock.html">IO::InputBlock</a> &gt; &amp;ek=std::nullopt)</td></tr>
<tr class="memdesc:a8802c2a4b75640fab5e08c6f0d3b9a6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms + stores correlation potential Sigma. <br /></td></tr>
<tr class="separator:a8802c2a4b75640fab5e08c6f0d3b9a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421ef0086c7d2a879947bc2691b7bfbc"><td class="memItemLeft" align="right" valign="top"><a id="a421ef0086c7d2a879947bc2691b7bfbc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>copySigma</b> (const MBPT::CorrelationPotential *const <a class="el" href="classWavefunction.html#adc7d0dcd7f34e802399a123dfc91723a">Sigma</a>)</td></tr>
<tr class="separator:a421ef0086c7d2a879947bc2691b7bfbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23a70d8cb483ccd17a025e1b0ffd25c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#ac23a70d8cb483ccd17a025e1b0ffd25c">update_Vnuc</a> (const std::vector&lt; double &gt; &amp;v_new)</td></tr>
<tr class="memdesc:ac23a70d8cb483ccd17a025e1b0ffd25c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows extra potential to be added to Vnuc (updates both in Wavefunction.  <a href="classWavefunction.html#ac23a70d8cb483ccd17a025e1b0ffd25c">More...</a><br /></td></tr>
<tr class="separator:ac23a70d8cb483ccd17a025e1b0ffd25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e99495299b73cd5ff9dd2f1f4b22a66"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a2e99495299b73cd5ff9dd2f1f4b22a66">lminmax_core_range</a> (int l, double eps=0.0) const</td></tr>
<tr class="memdesc:a2e99495299b73cd5ff9dd2f1f4b22a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns [min,max] r values for which the core density (given l) is larger than cutoff (= eps*max_value)  <a href="classWavefunction.html#a2e99495299b73cd5ff9dd2f1f4b22a66">More...</a><br /></td></tr>
<tr class="separator:a2e99495299b73cd5ff9dd2f1f4b22a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ababc5fbcf192d52242592d4c3b6b8fbe"><td class="memItemLeft" align="right" valign="top"><a id="ababc5fbcf192d52242592d4c3b6b8fbe"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#ababc5fbcf192d52242592d4c3b6b8fbe">H0ab</a> (const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;Fa, const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;Fb) const</td></tr>
<tr class="memdesc:ababc5fbcf192d52242592d4c3b6b8fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns &lt;a|H|b&gt; for Hamiltonian H (inludes Rad.pot, NOT sigma, Breit, or exchange!) <br /></td></tr>
<tr class="separator:ababc5fbcf192d52242592d4c3b6b8fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2b7bc99337624a10625bf8654c5bfe"><td class="memItemLeft" align="right" valign="top"><a id="a1b2b7bc99337624a10625bf8654c5bfe"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a1b2b7bc99337624a10625bf8654c5bfe">H0ab</a> (const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;Fa, const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;dFa, const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;Fb, const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;dFb) const</td></tr>
<tr class="memdesc:a1b2b7bc99337624a10625bf8654c5bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns &lt;a|H|b&gt; for Hamiltonian H (inludes Rad.pot, NOT sigma, Breit, or exchange!) <br /></td></tr>
<tr class="separator:a1b2b7bc99337624a10625bf8654c5bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc490d63cc2a28c8aee6f803fd26731"><td class="memItemLeft" align="right" valign="top"><a id="aedc490d63cc2a28c8aee6f803fd26731"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>Hab</b> (const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;Fa, const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;Fb) const</td></tr>
<tr class="separator:aedc490d63cc2a28c8aee6f803fd26731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd2a0f0b79bb87d7266dba526342f1ed"><td class="memItemLeft" align="right" valign="top"><a id="abd2a0f0b79bb87d7266dba526342f1ed"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ConfigurationInteraction</b> (const <a class="el" href="classIO_1_1InputBlock.html">IO::InputBlock</a> &amp;input)</td></tr>
<tr class="separator:abd2a0f0b79bb87d7266dba526342f1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Stores Wavefunction (set of valence orbitals, grid, HF etc.) </p>
<dl class="section user"><dt>Construction:</dt><dd><ul>
<li>Set of GridParameters [see Maths/Grid]</li>
<li>Set of Nuclear::Nucleus [see Physics/NuclearPotentials]</li>
<li>var_alpha = \(\lambda\), \(\alpha = \lambda\alpha_0\)</li>
<li>run_label: Optional label for output identity - for distinguishing outputs with different parameters </li>
</ul>
</dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a2ebe5ad5f71d03f2b34c2bad30c48b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ebe5ad5f71d03f2b34c2bad30c48b2e">&#9670;&nbsp;</a></span>getState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> * Wavefunction::getState </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds requested state; returns nullptr if not found. </p>
<p>is_valence is optional out-parameter; tells you where orb was found </p>

</div>
</div>
<a id="a2e99495299b73cd5ff9dd2f1f4b22a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e99495299b73cd5ff9dd2f1f4b22a66">&#9670;&nbsp;</a></span>lminmax_core_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; double, double &gt; Wavefunction::lminmax_core_range </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns [min,max] r values for which the core density (given l) is larger than cutoff (= eps*max_value) </p>
<p>Returns the r values (au) for which the value of rho = \sum|psi^2|(r) drops below cutoff. Sum goes over all m for given l. Cut-off defined as eps*max, where max is maximum value for rho(r). Set l&lt;0 to get for all l (entire core) </p>

</div>
</div>
<a id="a188d1b21e04a394d5ff1ed7af5251083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188d1b21e04a394d5ff1ed7af5251083">&#9670;&nbsp;</a></span>printValence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wavefunction::printValence </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tmp_orbitals</em> = <code>{}</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints table of valence orbitals + energies etc. </p>
<p>Can optionally give it any list of orbitals to print </p>

</div>
</div>
<a id="ac23a70d8cb483ccd17a025e1b0ffd25c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23a70d8cb483ccd17a025e1b0ffd25c">&#9670;&nbsp;</a></span>update_Vnuc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Wavefunction::update_Vnuc </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>v_new</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows extra potential to be added to Vnuc (updates both in Wavefunction. </p>
<p>nb: two versions of Vnuc...</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Wavefunction/<a class="el" href="Wavefunction_8hpp_source.html">Wavefunction.hpp</a></li>
<li>Wavefunction/Wavefunction.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jul 12 2024 07:43:56 for ampsci by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
